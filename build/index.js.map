{"version":3,"sources":["../src/index.js"],"names":["isPromise","val","then","assert","condition","msg","Error","Process","type","process","is","TypeError","channels","call","callback","error","rmListeners","emitter","Object","values","forEach","channel","removeAllListeners","IpcFlux","options","env","NODE_ENV","Promise","actions","instance","_actions","create","actionEmitHandler","event","arg","actionExists","action","target","getCurrentWindow","id","act","dispatchAction","payload","data","sender","send","emitterCallListener","callType","on","err","console","dispatchExternalAction","dispatch","dispatchExternal","resolve","listener","removeListener","keys","registerAction","_caller","_action","_payload","entry","length","all","map","handler","_target","fromId","webContents","Array","isArray","push","cb","res"],"mappings":"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","file":"index.js","sourcesContent":["import { ipcMain, ipcRenderer, webContents, remote } from 'electron';\n\nconst isPromise = (val) => {\n\treturn val && typeof val.then === 'function';\n}\n\nconst assert = (condition, msg) => {\n\tif (!condition) {\n\t\tthrow new Error(`[IpcFlux] ${msg}`);\n\t}\n}\n\n// determines process originating from\nconst Process = {\n\t// return the type of process as a string\n\ttype: () => {\n\t\t// running in browser/electron window\n\t\tif (typeof process === 'undefined') {\n\t\t\treturn 'renderer';\n\t\t}\n\n\t\t// node-integration disabled\n\t\tif (!process) {\n\t\t\treturn 'renderer';\n\t\t}\n\n\t\t// node.js\n\t\tif (!process.type) {\n\t\t\treturn 'main';\n\t\t}\n\n\t\treturn process.type === 'renderer' ? 'renderer' : 'main';\n\t},\n\t// explicit process type checking\n\tis: (type) => {\n\t\tif (typeof type === 'string') {\n\t\t\treturn type === Process.type();\n\t\t} else {\n\t\t\tthrow new TypeError('type of `type` was not string');\n\t\t}\n\t}\n}\n\n// predefined channels\nconst channels = {\n\tcall: 'IpcFlux-Call',\n\tcallback: 'IpcFlux-Callback',\n\terror: 'IpcFlux-Error'\n};\n\n// remove all active IpcFlux listeners for the current process\nconst rmListeners = () => {\n\tconst emitter = Process.is('main') ? ipcMain : ipcRenderer;\n\n\tObject.values(channels).forEach((channel) => {\n\t\temitter.removeAllListeners(channel);\n\t});\n}\n\nclass IpcFlux {\n\tconstructor(options = {}) {\n\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t// check if Promises can be used\n\t\t\tassert(typeof Promise !== 'undefined', 'IpcFlux requires Promises to function.');\n\t\t\tassert(this instanceof IpcFlux, 'IpcFlux must be called with the new operator.');\n\t\t}\n\n\t\t// remove IpcFlux listeners\n\t\trmListeners();\n\n\t\tconst { actions={} } = options;\n\n\t\t// defined due to `this` being reassigned in arrow functions\n\t\tconst instance = this;\n\n\t\tthis._actions = Object.create(null);\n\n\t\t// the listener to be called for actions\n\t\tconst actionEmitHandler = (event, arg) => {\n\t\t\tif (instance.actionExists(arg.action)) {\n\t\t\t\tconst target = Process.is('renderer') ? remote.getCurrentWindow().id : arg.target;\n\n\t\t\t\tconst act = instance.dispatchAction({ ...arg, target }, arg.action, arg.payload);\n\n\t\t\t\tif (isPromise(act)) {\n\t\t\t\t\t// on Promise complete, send a callback to the dispatcher\n\t\t\t\t\tact.then((data) => {\n\t\t\t\t\t\tevent.sender.send(channels.callback, {\n\t\t\t\t\t\t\t...arg,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// send a callback to the dispatcher\n\t\t\t\t\tevent.sender.send(channels.error, `[IpcFlux] '${arg.action}' action called from ${arg.process} process, in ${Process.type()} process, did not return a Promise`);\n\t\t\t\t\tevent.sender.send(channels.callback, {\n\t\t\t\t\t\t...arg,\n\t\t\t\t\t\ttarget\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if the action doesn't exist, send an error message back to the caller\n\t\t\t\tevent.sender.send(channels.error, `[IpcFlux] unknown action called from ${arg.process} process, in ${Process.type()} process: ${arg.action}`);\n\t\t\t}\n\t\t}\n\n\t\t// run on `channel.call`\n\t\tconst emitterCallListener = (event, arg) => {\n\t\t\tif (typeof arg !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch(arg.callType) {\n\t\t\t\t// if the call type is an action, let `actionEmitHandler` handle it\n\t\t\t\tcase 'action':\n\t\t\t\t\tactionEmitHandler(event, arg);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// define the process emitter, minimizes code duplication\n\t\tconst emitter = Process.is('main') ? ipcMain : ipcRenderer;\n\n\t\t// the emitter event handlers for calls and errors\n\t\temitter.on(channels.call, emitterCallListener);\n\t\temitter.on(channels.error, (event, err) => {\n\t\t\tconsole.error(err);\n\t\t});\n\n\t\tconst { dispatchAction, dispatchExternalAction } = this;\n\n\t\tthis.dispatch = (type, payload) => {\n\t\t\treturn dispatchAction.call(instance, {\n\t\t\t\tprocess: Process.type(),\n\t\t\t\ttarget: Process.is('renderer') ? remote.getCurrentWindow().id : null\n\t\t\t}, type, payload);\n\t\t}\n\n\t\tthis.dispatchExternal = (target, action, payload) => {\n\t\t\t// return a promise of the dispatch, resolving on callback\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tdispatchExternalAction.call(instance, target, action, payload);\n\n\t\t\t\t// only resolve if the action callback is the same as that called, then remove the callback handler\n\t\t\t\tconst listener = (event, arg) => {\n\t\t\t\t\tif (arg.action === action) {\n\t\t\t\t\t\temitter.removeListener(channels.callback, listener);\n\t\t\t\t\t\tresolve(arg.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// setup a callback listener\n\t\t\t\temitter.on(channels.callback, listener);\n\t\t\t});\n\t\t}\n\n\t\t// register all actions defined in the class constructor options\n\t\tObject.keys(actions).forEach((action) => {\n\t\t\tthis.registerAction(action, actions[action]);\n\t\t});\n\t}\n\n\tactionExists(action) {\n\t\treturn !!this._actions[action];\n\t}\n\n\tdispatchAction(_caller, _action, _payload) {\n\t\tconst { action, payload } = {\n\t\t\taction: _action,\n\t\t\tpayload: _payload\n\t\t};\n\n\t\tconst entry = this._actions[action];\n\n\t\t// if no action was found\n\t\tif (!entry) {\n\t\t\t// action was dispatched from this process, show the error in this process\n\t\t\tif (_caller.process === Process.type()) {\n\t\t\t\tconsole.error(`[IpcFlux] unknown action: ${action}`);\n\t\t\t}\n\t\t\t// action existence is checked in `actionListener` above, as we don't know the actions defined in the other process\n\t\t\treturn;\n\t\t}\n\n\t\t// return a promise of the action function, async\n\t\treturn entry.length > 1 ? Promise.all(entry.map(handler => handler(payload))) : entry[0](payload);\n\t}\n\n\tdispatchExternalAction(_target, _action, _payload) {\n\t\t// same for both process types\n\t\tlet arg = {\n\t\t\tprocess: Process.type(),\n\t\t\tcallType: 'action'\n\t\t};\n\n\t\tif (Process.is('main')) {\n\t\t\t// checks target is an instance of BrowserWindow, or if is a BrowserWindow id\n\t\t\tif (typeof _target === 'object' || typeof _target === 'number') {} else {\n\t\t\t\tconsole.error('[IpcFlux] target passed is not instanceof BrowserWindow or an active BrowserWindow\\'s id');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// converts BrowserWindow or BrowserWindow id to webContents for instance checking\n\t\t\t_target = typeof _target === 'number' ? webContents.fromId(_target) : webContents in _target ? _target.webContents : {}\n\n\t\t\tif(!(_target instanceof webContents)) {\n\t\t\t\tconsole.error('[IpcFlux] target passed is not an instanceof BrowserWindow or an active BrowserWindow\\'s id');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof _action !== 'string') {\n\t\t\t\tconsole.error('[IpcFlux] action not passed as parameter');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// add the payload to `arg` if not undefined\n\t\t\tif (typeof _payload !== 'undefined') {\n\t\t\t\targ.payload = _payload;\n\t\t\t}\n\t\t\twebContents.fromId(_target.webContents.id).send(channels.call, {\n\t\t\t\t...arg,\n\t\t\t\taction: _action,\n\t\t\t\t// send the target BrowserWindow id for callback and error handling\n\t\t\t\ttarget: _target.webContents.id\n\t\t\t});\n\t\t} else if (Process.is('renderer')) {\n\t\t\t// _target param is action, and _action param is payload because renderer process does not require target BrowserWindow to be passed\n\t\t\tconst { _action, _payload } = {\n\t\t\t\t_action: _target,\n\t\t\t\t_payload: _action\n\t\t\t};\n\n\t\t\tif (typeof _action !== 'string') {\n\t\t\t\tconsole.error('[IpcFlux] action not passed as parameter');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// add the payload to `arg` if not undefined\n\t\t\tif (typeof _payload !== 'undefined') {\n\t\t\t\targ.payload = _payload;\n\t\t\t}\n\n\t\t\t// send a call to the main process to dispatch the action\n\t\t\tipcRenderer.send(channels.call, {\n\t\t\t\t...arg,\n\t\t\t\taction: _action,\n\t\t\t\t// send the current BrowserWindow id for callback and error handling\n\t\t\t\ttarget: remote.getCurrentWindow().id\n\t\t\t});\n\t\t}\n\t}\n\n\tregisterAction(action, handler) {\n\t\tconst instance = this;\n\n\t\t// checks if action is in `_actions` array, if not, create an array at the required key\n\t\tconst entry = Array.isArray(instance._actions[action]) ? instance._actions[action] : instance._actions[action] = [];\n\n\t\t// add the action to the array\n\t\t// note that this allows actions to be created using the same action_name, but with different handlers without being overwritten\n\t\tentry.push((payload, cb) => {\n\t\t\t// add the handler to `_actions`, passing in { dispatch, dispatchExternal } for use within the action, as well as the payload and callback\n\t\t\tlet res = handler({\n\t\t\t\tdispatch: instance.dispatch,\n\t\t\t\tdispatchExternal: instance.dispatchExternal\n\t\t\t}, payload, cb);\n\n\t\t\t// if not already a Promise, make it one\n\t\t\tif (!isPromise(res)) {\n\t\t\t\tres = Promise.resolve(res);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t});\n\t}\n}\n\nexport default IpcFlux"]}