{"version":3,"sources":["../src/index.js"],"names":["Process","assert","isPromise","channels","call","callback","error","handshake","default","success","rmListeners","emitter","is","Object","values","forEach","channel","subchannel","removeAllListeners","IpcFlux","options","env","type","Promise","actions","config","instance","_actions","create","_config","timeout","actionEmitHandler","event","arg","actionExists","action","target","getCurrentWindow","id","act","dispatchAction","payload","then","data","sender","send","process","emitterCallListener","callType","on","err","Error","message","console","warn","log","dispatchExternalAction","dispatch","dispatchExternal","resolve","listener","removeListener","keys","registerAction","debug","done","total","completed","callbacks_sent","targets","initiated","callback_received","beginHandshake","handshakeListener","push","mainHandshakeListener","indexOf","setTimeout","cause","length","getAllWebContents","win","rendererHandshakeListener","_caller","_action","_payload","entry","all","map","handler","_target","fromId","webContents","Array","isArray","cb","res"],"mappings":"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","file":"index.js","sourcesContent":["//     _                  _____\n//    (_)__  ____  ____  / _/ /_ ____ __\n//   / / _ \\/ __/ /___/ / _/ / // /\\ \\ /\n//  /_/ .__/\\__/       /_//_/\\_,_//_\\_\\\n//   /_/\n//\n//\tipc-flux\n//\n//\tgithub - https://github.com/harryparkdotio/ipc-flux\n//\tnpm - https://www.npmjs.com/package/ipc-flux\n//\n//\t@harryparkdotio - harry@harrypark.io\n//\n//\tMIT license\n//\n\nimport { ipcMain, ipcRenderer, webContents, remote } from 'electron';\n\nimport utils from './utils';\nconst { Process, assert, isPromise } = utils;\n\n// predefined channels\nconst channels = {\n\tcall: 'IpcFlux-Call',\n\tcallback: 'IpcFlux-Callback',\n\terror: 'IpcFlux-Error',\n\thandshake: {\n\t\tdefault: 'IpcFlux-Handshake',\n\t\tcallback: 'IpcFlux-Handshake-Callback',\n\t\tsuccess: 'IpcFlux-Handshake-Success'\n\t}\n};\n\n// remove all active IpcFlux listeners for the current process\nconst rmListeners = () => {\n\tconst emitter = Process.is('main') ? ipcMain : ipcRenderer;\n\n\tObject.values(channels).forEach((channel) => {\n\t\ttypeof channel === 'object' ? Object.values(channel).forEach((subchannel) => {\n\t\t\temitter.removeAllListeners(subchannel);\n\t\t}) : emitter.removeAllListeners(channel);\n\t});\n}\n\nclass IpcFlux {\n\tconstructor(options = {}) {\n\t\tif (Process.env.type() !== 'production') {\n\t\t\t// check if Promises can be used\n\t\t\tassert(typeof Promise !== 'undefined', '[IpcFlux] requires Promises to function.');\n\t\t\tassert(this instanceof IpcFlux, '[IpcFlux] must be called with the new operator.');\n\t\t}\n\n\t\t// remove IpcFlux listeners\n\t\trmListeners();\n\n\t\tconst { actions={}, config={} } = options;\n\n\t\t// defined due to `this` being reassigned in arrow functions\n\t\tconst instance = this;\n\n\t\tthis._actions = Object.create(null);\n\t\tthis._config = Object.create(null);\n\n\t\tthis._config = {\n\t\t\thandshake: {\n\t\t\t\ttimeout: 10000\n\t\t\t},\n\t\t\t...config\n\t\t}\n\n\t\t// the listener to be called for actions\n\t\tconst actionEmitHandler = (event, arg) => {\n\t\t\tif (instance.actionExists(arg.action)) {\n\t\t\t\tconst target = Process.is('renderer') ? remote.getCurrentWindow().id : arg.target;\n\n\t\t\t\tconst act = instance.dispatchAction({ ...arg, target }, arg.action, arg.payload);\n\n\t\t\t\tif (isPromise(act)) {\n\t\t\t\t\t// on Promise complete, send a callback to the dispatcher\n\t\t\t\t\tact.then((data) => {\n\t\t\t\t\t\tevent.sender.send(channels.callback, {\n\t\t\t\t\t\t\t...arg,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// send a callback to the dispatcher\n\t\t\t\t\tevent.sender.send(channels.error, `[IpcFlux] '${arg.action}' action called from ${arg.process} process, in ${Process.type()} process, did not return a Promise`);\n\t\t\t\t\tevent.sender.send(channels.callback, {\n\t\t\t\t\t\t...arg,\n\t\t\t\t\t\ttarget\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if the action doesn't exist, send an error message back to the caller\n\t\t\t\tevent.sender.send(channels.error, `[IpcFlux] unknown action called from ${arg.process} process, in ${Process.type()} process: ${arg.action}`);\n\t\t\t}\n\t\t}\n\n\t\t// run on `channel.call`\n\t\tconst emitterCallListener = (event, arg) => {\n\t\t\tif (typeof arg !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch(arg.callType) {\n\t\t\t\t// if the call type is an action, let `actionEmitHandler` handle it\n\t\t\t\tcase 'action':\n\t\t\t\t\tactionEmitHandler(event, arg);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// define the process emitter, minimizes code duplication\n\t\tconst emitter = Process.is('main') ? ipcMain : ipcRenderer;\n\n\t\t// the emitter event handlers for calls and errors\n\t\temitter.on(channels.call, emitterCallListener);\n\t\temitter.on(channels.error, (event, err) => {\n\t\t\tif (typeof err === 'object') {\n\t\t\t\tif (err.type === 'throw') {\n\t\t\t\t\tthrow new Error(err.message);\n\t\t\t\t} else if (err.type === 'console' || err.type === 'error') {\n\t\t\t\t\tconsole.error(err.message);\n\t\t\t\t} else if (err.type === 'warn') {\n\t\t\t\t\tconsole.warn(err.message);\n\t\t\t\t} else if (err.type === 'log') {\n\t\t\t\t\tconsole.log(err.message);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(err);\n\t\t\t}\n\t\t});\n\n\t\tconst { dispatchAction, dispatchExternalAction } = this;\n\n\t\tthis.dispatch = (type, payload) => {\n\t\t\treturn dispatchAction.call(instance, {\n\t\t\t\tprocess: Process.type(),\n\t\t\t\ttarget: Process.is('renderer') ? remote.getCurrentWindow().id : null\n\t\t\t}, type, payload);\n\t\t}\n\n\t\tthis.dispatchExternal = (target, action, payload) => {\n\t\t\t// return a promise of the dispatch, resolving on callback\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\tdispatchExternalAction.call(instance, target, action, payload);\n\n\t\t\t\t// only resolve if the action callback is the same as that called, then remove the callback handler\n\t\t\t\tconst listener = (event, arg) => {\n\t\t\t\t\tif (Process.is('renderer') ? arg.action === target : arg.action === action) {\n\t\t\t\t\t\temitter.removeListener(channels.callback, listener);\n\t\t\t\t\t\tresolve(arg.data);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// setup a callback listener\n\t\t\t\temitter.on(channels.callback, listener);\n\t\t\t});\n\t\t}\n\n\t\t// register all actions defined in the class constructor options\n\t\tObject.keys(actions).forEach((action) => {\n\t\t\tthis.registerAction(action, actions[action]);\n\t\t});\n\n\t\tthis.debug = {\n\t\t\tprocess: Process.type(),\n\t\t\tchannels\n\t\t}\n\n\t\t// define the handshake config, specific to the process type\n\t\tthis.handshake = Process.is('main') ? {\n\t\t\tdone: 0,\n\t\t\ttotal: 0,\n\t\t\tcompleted: false,\n\t\t\tcallbacks_sent: 0,\n\t\t\ttargets: [],\n\t\t\ttimeout: this._config.handshake.timeout\n\t\t} : {\n\t\t\tcompleted: false,\n\t\t\ttimeout: this._config.handshake.timeout,\n\t\t\tinitiated: false,\n\t\t\tcallback_received: false\n\t\t}\n\n\t\t// start the handshaking process\n\t\tthis.beginHandshake();\n\t}\n\n\tbeginHandshake() {\n\t\tconst { handshake } = this;\n\n\t\tif (Process.is('main')) {\n\t\t\tconst handshakeListener = (event, arg) => {\n\t\t\t\thandshake.total += 1;\n\t\t\t\t// add target to targets, used to determine which handshakes pass/fail\n\t\t\t\thandshake.targets.push(arg.target);\n\n\t\t\t\t// return handshake with target\n\t\t\t\tevent.sender.send(channels.handshake.callback, {\n\t\t\t\t\ttarget: arg.target\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// create a listener, each handshake is initiated from the renderer\n\t\t\tipcMain.on(channels.handshake.default, handshakeListener);\n\n\t\t\tconst mainHandshakeListener = (event, arg) => {\n\t\t\t\t// if the target has already been added (initial handshake successful)\n\t\t\t\tif (handshake.targets.indexOf(arg.target) >= 0) {\n\t\t\t\t\thandshake.done += 1;\n\t\t\t\t\thandshake.completed = (handshake.done === handshake.total);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('[IpcFlux] handshake return from unknown BrowserWindow id');\n\t\t\t\t}\n\n\t\t\t\tif (handshake.completed) {\n\t\t\t\t\t// remove this handshake listener\n\t\t\t\t\tipcMain.removeListener(channels.handshake.success, mainHandshakeListener);\n\t\t\t\t\tipcMain.removeListener(channels.handshake.default, handshakeListener);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tipcMain.on(channels.handshake.success, mainHandshakeListener);\n\n\t\t\t// called to check if handshakes have been completed\n\t\t\tsetTimeout(() => {\n\t\t\t\thandshake.completed = (handshake.done === handshake.total);\n\n\t\t\t\tif (!handshake.completed) {\n\t\t\t\t\tlet cause;\n\t\t\t\t\tif (handshake.callbacks_sent < handshake.total || handshake.callbacks_sent < handshake.targets.length) {\n\t\t\t\t\t\tcause = 'not all callbacks were returned';\n\t\t\t\t\t} else if (handshake.done < handshake.total) {\n\t\t\t\t\t\tcause = 'not all initiated handshakes completed';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcause = 'unknown error';\n\t\t\t\t\t}\n\n\t\t\t\t\t// send error to all windows\n\t\t\t\t\twebContents.getAllWebContents().forEach((win) => {\n\t\t\t\t\t\twin.send(channels.error, {\n\t\t\t\t\t\t\ttype: 'throw',\n\t\t\t\t\t\t\tmessage: `[IpcFlux] handshake failed (timeout): ${cause}`\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tthrow new Error(`[IpcFlux] handshake failed (timeout): ${cause}`);\n\t\t\t\t}\n\n\t\t\t\t// remove all main handshake listeners\n\t\t\t\tipcMain.removeAllListeners(channels.handshake.default);\n\t\t\t\tipcMain.removeAllListeners(channels.handshake.success);\n\t\t\t}, handshake.timeout);\n\t\t} else if (Process.is('renderer')) {\n\t\t\t// initiate the handshake\n\t\t\tipcRenderer.send(channels.handshake.default, {\n\t\t\t\ttarget: remote.getCurrentWindow().id\n\t\t\t});\n\t\t\thandshake.initiated = true;\n\n\t\t\tconst rendererHandshakeListener = (event, arg) => {\n\t\t\t\thandshake.callback_received = true;\n\t\t\t\tif (arg.target === remote.getCurrentWindow().id) {\n\t\t\t\t\t// return the handshake, verifies in main process handshake is complete\n\t\t\t\t\tevent.sender.send(channels.handshake.success, {\n\t\t\t\t\t\ttarget: arg.target\n\t\t\t\t\t});\n\t\t\t\t\thandshake.completed = true;\n\t\t\t\t\t// remove this listener\n\t\t\t\t\tipcRenderer.removeListener(channels.handshake.callback, rendererHandshakeListener);\n\n\t\t\t\t\t// remove all renderer handshake listeners\n\t\t\t\t\tipcRenderer.removeAllListeners(channels.handshake.default);\n\t\t\t\t\tipcRenderer.removeAllListeners(channels.handshake.callback);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tipcRenderer.on(channels.handshake.callback, rendererHandshakeListener);\n\n\t\t\t// called to check if this handshake has been completed\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (!handshake.done) {\n\t\t\t\t\tlet cause;\n\t\t\t\t\tif (handshake.initiated === false) {\n\t\t\t\t\t\tcause = 'handshake not initiated';\n\t\t\t\t\t} else if (handshake.callback_received === false) {\n\t\t\t\t\t\tcause = 'handshake callback not received';\n\t\t\t\t\t} else if (handshake.completed === false) {\n\t\t\t\t\t\tcause = 'handshake was not completed';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcause = 'unknown error';\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`[IpcFlux] handshake failed (timeout): ${cause}`);\n\t\t\t\t}\n\n\t\t\t\t// remove all renderer handshake listeners\n\t\t\t\tipcRenderer.removeAllListeners(channels.handshake);\n\t\t\t\tipcRenderer.removeAllListeners(channels.handshake.callback);\n\t\t\t}, handshake.timeout);\n\t\t}\n\t}\n\n\tactionExists(action) {\n\t\treturn !!this._actions[action];\n\t}\n\n\tdispatchAction(_caller, _action, _payload) {\n\t\tconst { action, payload } = {\n\t\t\taction: _action,\n\t\t\tpayload: _payload\n\t\t};\n\n\t\tconst entry = this._actions[action];\n\n\t\t// if no action was found\n\t\tif (!entry) {\n\t\t\t// action was dispatched from this process, show the error in this process\n\t\t\tif (_caller.process === Process.type()) {\n\t\t\t\tconsole.error(`[IpcFlux] unknown action: ${action}`);\n\t\t\t}\n\t\t\t// action existence is checked in `actionListener` above, as we don't know the actions defined in the other process\n\t\t\treturn;\n\t\t}\n\n\t\t// return a promise of the action function, async\n\t\treturn entry.length > 1 ? Promise.all(entry.map(handler => handler(payload))) : entry[0](payload);\n\t}\n\n\tdispatchExternalAction(_target, _action, _payload) {\n\t\t// same for both process types\n\t\tlet arg = {\n\t\t\tprocess: Process.type(),\n\t\t\tcallType: 'action'\n\t\t};\n\n\t\tif (Process.is('main')) {\n\t\t\t// checks target is an instance of BrowserWindow, or if is a BrowserWindow id\n\t\t\tif (typeof _target === 'object' || typeof _target === 'number') {} else {\n\t\t\t\tconsole.error('[IpcFlux] target passed is not instanceof BrowserWindow or an active BrowserWindow\\'s id');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// converts BrowserWindow or BrowserWindow id to webContents for instance checking\n\t\t\t_target = typeof _target === 'number' ? webContents.fromId(_target) : webContents in _target ? _target.webContents : {}\n\n\t\t\tif(!(_target instanceof webContents)) {\n\t\t\t\tconsole.error('[IpcFlux] target passed is not an instanceof BrowserWindow or an active BrowserWindow\\'s id');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof _action !== 'string') {\n\t\t\t\tconsole.error('[IpcFlux] action not passed as parameter');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// add the payload to `arg` if not undefined\n\t\t\tif (typeof _payload !== 'undefined') {\n\t\t\t\targ.payload = _payload;\n\t\t\t}\n\t\t\twebContents.fromId(_target.webContents.id).send(channels.call, {\n\t\t\t\t...arg,\n\t\t\t\taction: _action,\n\t\t\t\t// send the target BrowserWindow id for callback and error handling\n\t\t\t\ttarget: _target.webContents.id\n\t\t\t});\n\t\t} else if (Process.is('renderer')) {\n\t\t\t// _target param is action, and _action param is payload because renderer process does not require target BrowserWindow to be passed\n\t\t\tconst { _action, _payload } = {\n\t\t\t\t_action: _target,\n\t\t\t\t_payload: _action\n\t\t\t};\n\n\t\t\tif (typeof _action !== 'string') {\n\t\t\t\tconsole.error('[IpcFlux] action not passed as parameter');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// add the payload to `arg` if not undefined\n\t\t\tif (typeof _payload !== 'undefined') {\n\t\t\t\targ.payload = _payload;\n\t\t\t}\n\n\t\t\t// send a call to the main process to dispatch the action\n\t\t\tipcRenderer.send(channels.call, {\n\t\t\t\t...arg,\n\t\t\t\taction: _action,\n\t\t\t\t// send the current BrowserWindow id for callback and error handling\n\t\t\t\ttarget: remote.getCurrentWindow().id\n\t\t\t});\n\t\t}\n\t}\n\n\tregisterAction(action, handler) {\n\t\tconst instance = this;\n\n\t\t// checks if action is in `_actions` array, if not, create an array at the required key\n\t\tconst entry = Array.isArray(instance._actions[action]) ? instance._actions[action] : instance._actions[action] = [];\n\n\t\t// add the action to the array\n\t\t// note that this allows actions to be created using the same action_name, but with different handlers without being overwritten\n\t\tentry.push((payload, cb) => {\n\t\t\t// add the handler to `_actions`, passing in { dispatch, dispatchExternal } for use within the action, as well as the payload and callback\n\t\t\tlet res = handler({\n\t\t\t\tdispatch: instance.dispatch,\n\t\t\t\tdispatchExternal: instance.dispatchExternal\n\t\t\t}, payload, cb);\n\n\t\t\t// if not already a Promise, make it one\n\t\t\tif (!isPromise(res)) {\n\t\t\t\tres = Promise.resolve(res);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t});\n\t}\n}\n\nexport default IpcFlux"]}