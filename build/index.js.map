{"version":3,"sources":["../src/index.js"],"names":["Process","assert","isPromise","channels","call","callback","error","handshake","default","success","finish","rmListeners","emitter","is","Object","values","forEach","channel","subchannel","removeAllListeners","IpcFlux","options","env","type","Promise","actions","config","instance","_actions","create","_config","maxListeners","timeout","debug","actionEmitHandler","event","arg","actionExists","action","target","getCurrentWindow","id","act","dispatch","payload","then","data","sender","send","process","emitterCallListener","callType","setMaxListeners","on","err","Error","message","console","warn","log","dispatchExternal","resolve","reject","listener","removeListener","keys","registerAction","targets","initiated","pending","completed","promise","beginHandshake","endHandshake","targ","handshakePromise","setTimeout","fromId","catch","push","once","_caller","_action","_payload","entry","length","all","map","handler","_target","webContents","Array","isArray","cb","res"],"mappings":"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","file":"index.js","sourcesContent":["//\n//     _                  _____\n//    (_)__  ____  ____  / _/ /_ ____ __\n//   / / _ \\/ __/ /___/ / _/ / // /\\ \\ /\n//  /_/ .__/\\__/       /_//_/\\_,_//_\\_\\\n//   /_/\n//\n//\tipc-flux\n//\n//\tgithub - https://github.com/harryparkdotio/ipc-flux\n//\tnpm - https://www.npmjs.com/package/ipc-flux\n//\n//\t@harryparkdotio - harry@harrypark.io\n//\n//\tMIT license\n//\n//\n\nimport { ipcMain, ipcRenderer, webContents, BrowserWindow, remote } from 'electron';\n\nimport utils from './utils';\nconst { Process, assert, isPromise } = utils;\n\n// predefined channels\nconst channels = {\n\tcall: 'IpcFlux-Call',\n\tcallback: 'IpcFlux-Callback',\n\terror: 'IpcFlux-Error',\n\thandshake: {\n\t\tdefault: 'IpcFlux-Handshake',\n\t\tcallback: 'IpcFlux-Handshake-Callback',\n\t\tsuccess: 'IpcFlux-Handshake-Success',\n\t\tfinish: 'IpcFlux-Handshake-Finish'\n\t}\n};\n\n// remove all active IpcFlux listeners for the current process\nconst rmListeners = () => {\n\tconst emitter = Process.is('main') ? ipcMain : ipcRenderer;\n\n\tObject.values(channels).forEach((channel) => {\n\t\ttypeof channel === 'object' ? Object.values(channel).forEach((subchannel) => {\n\t\t\temitter.removeAllListeners(subchannel);\n\t\t}) : emitter.removeAllListeners(channel);\n\t});\n}\n\nclass IpcFlux {\n\tconstructor(options = {}) {\n\t\tif (Process.env.type() !== 'production') {\n\t\t\t// check if Promises can be used\n\t\t\tassert(typeof Promise !== 'undefined', '[IpcFlux] requires Promises to function.');\n\t\t\tassert(this instanceof IpcFlux, '[IpcFlux] must be called with the new operator.');\n\t\t}\n\n\t\t// remove IpcFlux listeners\n\t\trmListeners();\n\n\t\tconst { actions={}, config={} } = options;\n\n\t\t// defined due to `this` being reassigned in arrow functions\n\t\tconst instance = this;\n\n\t\tthis._actions = Object.create(null);\n\t\tthis._config = Object.create(null);\n\n\t\tthis._config = {\n\t\t\tmaxListeners: 50,\n\t\t\thandshake: {\n\t\t\t\ttimeout: 10000\n\t\t\t},\n\t\t\tdebug: false,\n\t\t\t...config\n\t\t}\n\n\t\t// the listener to be called for actions\n\t\tconst actionEmitHandler = (event, arg) => {\n\t\t\tif (instance.actionExists(arg.action)) {\n\t\t\t\tconst target = Process.is('renderer') ? remote.getCurrentWindow().id : arg.target;\n\n\t\t\t\tconst act = dispatch.call(instance, { ...arg, target }, arg.action, arg.payload);\n\n\t\t\t\tif (isPromise(act)) {\n\t\t\t\t\t// on Promise complete, send a callback to the dispatcher\n\t\t\t\t\tact.then((data) => {\n\t\t\t\t\t\tevent.sender.send(channels.callback, {\n\t\t\t\t\t\t\t...arg,\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// send a callback to the dispatcher\n\t\t\t\t\tevent.sender.send(channels.error, `[IpcFlux] '${arg.action}' action called from ${arg.process} process, in ${Process.type()} process, did not return a Promise`);\n\t\t\t\t\tevent.sender.send(channels.callback, {\n\t\t\t\t\t\t...arg,\n\t\t\t\t\t\ttarget\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// if the action doesn't exist, send an error message back to the caller\n\t\t\t\tevent.sender.send(channels.error, `[IpcFlux] unknown action called from ${arg.process} process, in ${Process.type()} process: ${arg.action}`);\n\t\t\t}\n\t\t}\n\n\t\t// run on `channel.call`\n\t\tconst emitterCallListener = (event, arg) => {\n\t\t\tif (typeof arg !== 'object') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tswitch(arg.callType) {\n\t\t\t\t// if the call type is an action, let `actionEmitHandler` handle it\n\t\t\t\tcase 'action':\n\t\t\t\t\tactionEmitHandler(event, arg);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// define the process emitter, minimizes code duplication\n\t\tconst emitter = Process.is('main') ? ipcMain : ipcRenderer;\n\n\t\temitter.setMaxListeners(this._config.maxListeners);\n\n\t\t// the emitter event handlers for calls and errors\n\t\temitter.on(channels.call, emitterCallListener);\n\t\temitter.on(channels.error, (event, err) => {\n\t\t\tif (typeof err === 'object') {\n\t\t\t\tswitch(err.type) {\n\t\t\t\t\tcase 'throw':\n\t\t\t\t\t\tthrow new Error(err.message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'warn':\n\t\t\t\t\t\tconsole.warn(err.message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'warning':\n\t\t\t\t\t\tconsole.warn(err.message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'log':\n\t\t\t\t\t\tconsole.log(err.message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error(err.message);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(err);\n\t\t\t}\n\t\t});\n\n\t\tconst { dispatch, dispatchExternal } = this;\n\n\t\tthis.dispatch = (type, payload) => {\n\t\t\treturn dispatch.call(instance, {\n\t\t\t\tprocess: Process.type(),\n\t\t\t\ttarget: Process.is('renderer') ? remote.getCurrentWindow().id : 0\n\t\t\t}, type, payload);\n\t\t}\n\n\t\tthis.dispatchExternal = (target, action, payload) => {\n\t\t\t// return a promise of the dispatch, resolving on callback\n\t\t\tdispatchExternal.call(instance, target, action, payload);\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t// only resolve if the action callback is the same as that called, then remove the callback handler\n\t\t\t\tconst listener = (event, arg) => {\n\t\t\t\t\tif (Process.is('renderer') ? arg.action === target : arg.action === action) {\n\t\t\t\t\t\temitter.removeListener(channels.callback, listener);\n\t\t\t\t\t\tresolve(arg.data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject();\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// setup a callback listener\n\t\t\t\temitter.on(channels.callback, listener);\n\t\t\t});\n\t\t}\n\n\t\t// register all actions defined in the class constructor options\n\t\tObject.keys(actions).forEach((action) => {\n\t\t\tthis.registerAction(action, actions[action]);\n\t\t});\n\n\t\tthis.debug = {\n\t\t\tprocess: Process.type(),\n\t\t\tchannels\n\t\t}\n\n\t\t// define the handshake config, specific to the process type\n\t\tthis.handshake = Process.is('main') ? {\n\t\t\ttimeout: this._config.handshake.timeout,\n\t\t\ttargets: []\n\t\t} : {\n\t\t\ttimeout: this._config.handshake.timeout,\n\t\t\tinitiated: false,\n\t\t\tpending: false,\n\t\t\tcompleted: false,\n\t\t\tpromise: null\n\t\t}\n\n\t\t// start the handshaking process\n\t\tthis.beginHandshake();\n\n\t\tthis.endHandshake = () => {\n\t\t\t// remove all handshake listeners\n\t\t\tconst emitter = Process.is('main') ? ipcMain : ipcRenderer;\n\n\t\t\tObject.values(channels.handshake).forEach((channel) => {\n\t\t\t\temitter.removeAllListeners(channel);\n\t\t\t});\n\t\t}\n\t}\n\n\tbeginHandshake() {\n\t\tconst instance = this;\n\t\tconst { handshake } = this;\n\n\t\tif (Process.is('main')) {\n\t\t\tipcMain.on(channels.handshake.default, (event, arg) => {\n\t\t\t\tconst targ = arg.target;\n\n\t\t\t\tconst handshakePromise = new Promise((resolve, reject) => {\n\t\t\t\t\tipcMain.on(channels.handshake.success, (event, arg) => {\n\t\t\t\t\t\tif (arg.target === targ) {\n\t\t\t\t\t\t\tresolve(targ);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\treject(targ);\n\t\t\t\t\t}, handshake.timeout);\n\t\t\t\t}).then((target) => {\n\t\t\t\t\twebContents.fromId(target).send(channels.handshake.finish, {\n\t\t\t\t\t\ttarget\n\t\t\t\t\t});\n\n\t\t\t\t\treturn true;\n\t\t\t\t}).catch((target) => {\n\t\t\t\t\twebContents.fromId(target).send(channels.error, {\n\t\t\t\t\t\ttype: 'error',\n\t\t\t\t\t\tmessage: 'handshake failed'\n\t\t\t\t\t});\n\n\t\t\t\t\tconsole.error(`handshake failed: BrowserWindow (${target})`);\n\t\t\t\t});\n\n\t\t\t\thandshake.targets.push({\n\t\t\t\t\ttarget: targ,\n\t\t\t\t\tpromise: handshakePromise\n\t\t\t\t});\n\n\t\t\t\t// return handshake with target\n\t\t\t\tevent.sender.send(channels.handshake.callback, {\n\t\t\t\t\ttarget: arg.target\n\t\t\t\t});\n\t\t\t});\n\t\t} else if (Process.is('renderer')) {\n\t\t\tconst targ = remote.getCurrentWindow().id;\n\n\t\t\t// initiate the handshake\n\t\t\tipcRenderer.send(channels.handshake.default, {\n\t\t\t\ttarget: targ\n\t\t\t});\n\n\t\t\thandshake.promise = new Promise((resolve, reject) => {\n\t\t\t\tipcRenderer.on(channels.handshake.finish, (event, arg) => {\n\t\t\t\t\tif (arg.target === targ) {\n\t\t\t\t\t\thandshake.completed = true;\n\t\t\t\t\t\thandshake.pending = false;\n\t\t\t\t\t\tresolve(true);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\treject(false);\n\t\t\t\t}, handshake.timeout);\n\t\t\t}).catch(() => {\n\t\t\t\tipcRenderer.send(channels.error, {\n\t\t\t\t\ttype: 'error',\n\t\t\t\t\tmessage: `handshake failed: BrowserWindow (${remote.getCurrentWindow().id})`\n\t\t\t\t});\n\n\t\t\t\tconsole.error('handshake failed');\n\t\t\t});\n\n\t\t\thandshake.initiated = true;\n\t\t\thandshake.pending = true;\n\n\t\t\tipcRenderer.once(channels.handshake.callback, (event, arg) => {\n\t\t\t\tif (arg.target === targ) {\n\t\t\t\t\t// return the handshake, verifies in main process handshake is complete\n\t\t\t\t\tevent.sender.send(channels.handshake.success, {\n\t\t\t\t\t\ttarget: arg.target\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tactionExists(action) {\n\t\treturn !!this._actions[action];\n\t}\n\n\tdispatch(_caller, _action, _payload) {\n\t\tconst { action, payload } = {\n\t\t\taction: _action,\n\t\t\tpayload: _payload\n\t\t};\n\n\t\tconst entry = this._actions[action];\n\n\t\t// if no action was found\n\t\tif (!entry) {\n\t\t\t// action was dispatched from this process, show the error in this process\n\t\t\tif (_caller.process === Process.type()) {\n\t\t\t\tconsole.error(`[IpcFlux] unknown action: ${action}`);\n\t\t\t}\n\t\t\t// action existence is checked in `actionListener` above, as we don't know the actions defined in the other process\n\t\t\treturn;\n\t\t}\n\n\t\t// return a promise of the action function, async\n\t\treturn entry.length > 1 ? Promise.all(entry.map(handler => handler(payload))) : entry[0](payload);\n\t}\n\n\tdispatchExternal(_target, _action, _payload) {\n\t\t// same for both process types\n\t\tlet arg = {\n\t\t\tprocess: Process.type(),\n\t\t\tcallType: 'action'\n\t\t};\n\n\t\tlet { target, action, payload } = {\n\t\t\ttarget: _target,\n\t\t\taction: _action,\n\t\t\tpayload: _payload\n\t\t}\n\n\t\tif (Process.is('main')) {\n\t\t\t// checks target is an instance of BrowserWindow, or if is a BrowserWindow id\n\t\t\tif (typeof target === 'object' || typeof target === 'number') {} else {\n\t\t\t\tconsole.error('[IpcFlux] target passed is not instanceof BrowserWindow or an active BrowserWindow\\'s id');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// converts BrowserWindow or BrowserWindow id to webContents for instance checking\n\t\t\ttarget = typeof target === 'number' ? webContents.fromId(target) : target.webContents;\n\n\t\t\tif(!target.webContents) {\n\t\t\t\tconsole.error('[IpcFlux] target passed is not an instanceof BrowserWindow or an active BrowserWindow\\'s id');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof action !== 'string') {\n\t\t\t\tconsole.error('[IpcFlux] action not passed as parameter');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twebContents.fromId(target.webContents.id).send(channels.call, {\n\t\t\t\t...arg,\n\t\t\t\taction,\n\t\t\t\tpayload,\n\t\t\t\t// send the target BrowserWindow id for callback and error handling\n\t\t\t\ttarget: target.webContents.id\n\t\t\t});\n\t\t} else if (Process.is('renderer')) {\n\t\t\tif (typeof target !== 'string') {\n\t\t\t\tconsole.error('[IpcFlux] action not passed as parameter');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// send a call to the main process to dispatch the action\n\t\t\tipcRenderer.send(channels.call, {\n\t\t\t\t...arg,\n\t\t\t\taction: target,\n\t\t\t\tpayload: action,\n\t\t\t\t// send the current BrowserWindow id for callback and error handling\n\t\t\t\ttarget: remote.getCurrentWindow().id,\n\t\t\t});\n\t\t}\n\t}\n\n\tregisterAction(action, handler) {\n\t\tconst instance = this;\n\n\t\t// checks if action is in `_actions` array, if not, create an array at the required key\n\t\tconst entry = Array.isArray(instance._actions[action]) ? instance._actions[action] : instance._actions[action] = [];\n\n\t\t// add the action to the array\n\t\t// note that this allows actions to be created using the same action_name, but with different handlers without being overwritten\n\t\tentry.push((payload, cb) => {\n\t\t\t// add the handler to `_actions`, passing in { dispatch, dispatchExternal } for use within the action, as well as the payload and callback\n\t\t\tlet res = handler({\n\t\t\t\tdispatch: instance.dispatch,\n\t\t\t\tdispatchExternal: instance.dispatchExternal\n\t\t\t}, payload, cb);\n\n\t\t\t// if not already a Promise, make it one\n\t\t\tif (!isPromise(res)) {\n\t\t\t\tres = Promise.resolve(res);\n\t\t\t}\n\n\t\t\treturn res;\n\t\t});\n\t}\n}\n\nexport default IpcFlux"]}